<?xml version="1.1" encoding="UTF-8" standalone="yes"?>
<html>
 <head>
  <meta content="help/components/pages/article-3" name="sling:resourceType" />
  <meta content="07c3184a-5574-46dd-b235-d687a7760c0c" name="jcr:uuid" />
  <meta content="products:SG_EXPERIENCEMANAGER/6.4/SITES;topic_tags:spa;content_type:reference" name="cq:tags" />
  <meta content="2019-01-28T05:17:34.290-0500" name="cq:lastReplicated" />
  <meta content="en_us" name="jcr:language" />
  <meta content="" name="jcr:baseVersion" />
  <meta content="58756cad-5e62-4bf1-bb3d-238538b4772e" name="jcr:predecessors" />
  <meta content="This article presents important questions to consider when engaging a front-end developer to develop a SPA for AEM as well as gives an overview of the architecture of AEM with respect to SPAs to keep in mind when deploying a developed SPA on AEM." name="seoDescription" />
  <meta content="2018-12-11T04:52:16.598-0500" name="publishExternalDate" />
  <meta content="2018-12-11T04:52:16.598-0500" name="lastPublishExternalDate" />
  <meta content="Developing SPAs for AEM" name="jcr:title" />
  <meta content="bohnert" name="contentOwner" />
  <meta content="/apps/help/templates/article-3" name="cq:template" />
  <meta content="bohnert" name="cq:lastReplicatedBy" />
  <meta content="/etc/designs/help" name="cq:designPath" />
  <meta content="" name="jcr:versionHistory" />
  <meta content="Activate" name="cq:lastReplicationAction" />
  <meta content="admin" name="jcr:createdBy" />
  <meta content="" name="jcr:primaryType" />
  <meta content="https://helpx.adobe.com/experience-manager/6-4/sites/developing/using/spa-architecture.html" name="publishExternalURL" />
  <meta content="2018-06-08T07:29:09.969-0400" name="jcr:created" />
  <meta content="en" name="pageCreatedAt" />
  <meta content="audience:developing" name="primaryAudienceTag" />
  <meta content="2019-01-28T05:16:55.346-0500" name="cq:lastModified" />
  <meta content="/content/help/en/experience-manager/6-4/sites/developing/morehelp/spa;/content/help/en/experience-manager/6-4/sites/developing/morehelp/spa" name="moreHelpPaths" />
  <meta content="2018-12-11T04:52:16.598-0500" name="topicBrowsingSortDate" />
  <meta content="true" name="jcr:isCheckedOut" />
  <meta content="bohnert" name="cq:lastModifiedBy" />
  <meta content="bohnert@adobe.com" name="lr_lastReplicatedBy" />
  <meta content="products:SG_EXPERIENCEMANAGER/6.4/SITES" name="primaryProductTag" />
  <meta content="mix:versionable" name="jcr:mixinTypes" />
  <meta content="2018-06-29T13:56:42.202-0400" name="firstPublishExternalDate" />
 </head>
 <body>
  <p>Single page applications (SPAs) can offer compelling experiences for website users. Developers want to be able to build sites using SPA frameworks and authors want to seamlessly edit content within AEM for a site built using such frameworks.</p> 
  <p>This article presents important questions to consider when engaging a front-end developer to develop a SPA for AEM and gives an overview of the architecture of AEM with respect to deploying SPAs on AEM.</p> 
  <h2>SPA Development Principles for AEM</h2>
  <p>Developing single page applications on AEM assumes that the front-end developer observes standard best practices when creating an SPA. If as a 
   <g class="gr_ gr_13 gr-alert gr_spell gr_inline_cards gr_run_anim ContextualSpelling ins-del multiReplace" data-gr-id="13" id="13">
    front end
   </g> developer you follow these general best practices as well as few AEM-specific principles, your SPA will be functional with <a href="../../../sites/developing/using/spa-walkthrough.md#main-pars-header-1891759307">AEM and its content-authoring capabilities</a>.</p> 
  <ul> 
   <li><strong><a href="../../../sites/developing/using/spa-architecture.md#main-pars-header-2043724530">Portability</a> -</strong> As with any components, the components should be built to be as portable as possible. The SPA should be built with portably and reusable components, avoiding static paths that refer to the content structure.</li> 
   <li><strong><a href="../../../sites/developing/using/spa-architecture.md#main-pars-header-210126856">AEM Drives Site Structure</a> - </strong>The front-end developer creates components and owns their internal structure, but relies on AEM to define the content structure of the site.</li> 
   <li><strong><a href="../../../sites/developing/using/spa-architecture.md#main-pars-header-27915997">Dynamic Rendering</a> -</strong> All rendering should be dynamic.</li> 
   <li><strong><a href="/content#main-pars_header_1105486143">Dynamic Routing</a> -</strong> The SPA is responsible for the routing and AEM listens to it and fetches the component data based on it. Any routing should be dynamic as well.<br /> </li> 
  </ul> 
  <p>If you keep these principles in mind as you develop your SPA, it will be as flexible and as future proof as possible while enabling all supported AEM authoring functionality. </p> 
  <p>If you do not need to support AEM authoring features, you may need to consider a different <a href="../../../sites/developing/using/spa-architecture.md#main-pars-header-76407812">SPA design model</a>.<br /> </p> 
  <h3>Portability</h3>
  <p>As when developing any component, your components should be designed in such a way that maximizes their portability. Any patterns that work against the portability or reusability of the components should be avoided to ensure compatibility, flexibility, and maintainability going forward.</p> 
  <p>The developer should avoid using static paths that refer to the content structure as paths can be modified at any time by the content authors. This also restricts the reusability of the library and it prevents the AEM Template Editor from being used since its structure is located in another location than the content.</p> 
  <p>The resulting SPA should be built with highly portable and reusable components.<br /> </p> 
  <h3>AEM Drives Site Structure</h3>
  <p>The front end developer must think of himself or herself as responsible for creating a library of SPA components that are used to build the app. The front end developer has full control of the internal structure of the components. <a href="../../../sites/developing/using/spa-overview.md">However AEM at all times owns the structure of the site.</a></p> 
  <p>This means that the front end developer can add customer content before or after the entry point of the components and can also make third party calls inside the component. However the front end developer is not in full control of how the components nest for example.</p> 
  <h3>Dynamic Rendering</h3>
  <p>The SPA should only rely on dynamic rendering of content. This is the default expectation where AEM fetches and renders all children of the content structure.<a href="../../../sites/developing/using/spa-architecture.md#main-pars-header-2043724530"></a></p> 
  <p>Any explicit rendering that points to specific content is considered static rendering and though supported will not be compatible with AEM's content authoring features. This also goes against the principle of <a href="../../../sites/developing/using/spa-architecture.md#main-pars-header-2043724530">portability</a>.<br /> </p> 
  <h3>Dynamic Routing</h3>
  <p>As with rendering, all routing should also be dynamic. In AEM, <a href="../../../sites/developing/using/spa-routing.md">the SPA should always own the routing</a> and AEM listens to it and fetches content based on it.</p> 
  <p>Any static routing works against the <a href="../../../sites/developing/using/spa-architecture.md#main-pars-header-2043724530">principle of portability</a> and limits the author by not being compatible with content authoring features of AEM. For example, with static routing, if the content author would want to change a route or change a page, he or she would have to ask the front end developer to do it.</p> 
  <h2>Maven Archetype for SPA Starter Kit</h2>
  <p>Adobe recommends leveraging the <a href="https://github.com/adobe/aem-spa-project-archetype">Maven Archetype for SPA Starter Kit</a> to help you start your own SPA project for AEM.</p> 
  <h2>SPA Design Models</h2>
  <p>If the <a href="../../../sites/developing/using/spa-architecture.md#main-pars-header-831250252">principles of developing SPAs in AEM</a> are followed, then your SPA will be functional with all supported AEM content authoring features.<a href="../../../sites/developing/using/spa-architecture.md#main-pars-header-831250252"></a></p> 
  <p>There may be cases however when this is not entirely necessary. The following table gives an overview of the various design models, their advantages, and their disadvantages.<br /> </p> 
  <table border="1" cellpadding="1" cellspacing="0" width="100%"> 
   <tbody>
    <tr>
     <th><strong>Design Model<br /> </strong></th> 
     <th><strong>Advantages</strong></th> 
     <th><strong>Disadvantages</strong></th> 
    </tr>
    <tr>
     <td>AEM is used as a headless CMS without using the <a href="../../../sites/developing/using/spa-reference-materials.md">SPA Editor SDK framework.</a></td> 
     <td>The front end developer has full control over the app.</td> 
     <td><p>Content authors cannot leverage AEM's content authoring experience.</p> <p>The code is neither portable nor reusable if it contains static references or routing.</p> <p>Does not allow use of the template editor so the front end developer must maintain editable templates via the JCR.</p> </td> 
    </tr>
    <tr>
     <td>The front end developer uses the SPA Editor SDK framework but only opens some areas to the content author.</td> 
     <td>The developer keeps control over the app by only enabling authoring in restricted areas of the app.</td> 
     <td><p>Content authors are restricted to a limited set of AEM's content authoring experience.</p> <p>The code risks being neither portable nor reusable if it contains static references or routing.</p> <p>Does not allow use of the template editor so the front end developer must maintain editable templates via the JCR.</p> </td> 
    </tr>
    <tr>
     <td>The project fully leverages the SPA Editor SDK and the frontend components are developed as a library and the content structure of the app is delegated to AEM.</td> 
     <td><p>The app is reusable and portable.</p> <p>The content author can edit the app using AEM's content authoring experience.<br /> </p> <p>The SPA is compatible with the template editor.</p> </td> 
     <td><p>The developer is not in control of the structure of the app and the portion of content delegated to AEM.</p> <p>The developer can still reserve areas of the app for the content that is not meant to be authored using AEM.</p> </td> 
    </tr>
   </tbody>
  </table> 
  <note>
   <p>Although all models are supported in AEM, only by implementing the third (and thereby following the recommended <a href="../../../sites/developing/using/spa-architecture.md#main-pars-header-831250252">SPA development principles in AEM</a>) will the content authors be able to interact with and edit the content of the SPA in AEM as they are accustomed.<br /> <a href="../../../sites/developing/using/spa-architecture.md#main-pars-header-831250252"></a></p> 
  </note>
  <h2>Migrating Existing SPAs to AEM</h2>
  <p>Generally if your SPA follows the <a href="../../../sites/developing/using/spa-architecture.md#main-pars-header-831250252">SPA Development Principles for AEM</a>, then your SPA will work in AEM and be editable using the AEM SPA Editor.</p> 
  <p>Follow these steps to get your existing SPA ready to work with AEM.</p> 
  <ol>
   <li> <p>Make them capable of being rendered in any order, position and size.<br /> </p> </li>
   <li> <p>AEM provides a page and paragraph system component for you to use.</p> </li>
   <li> <p>The AEM components define the dialog and JSON output.</p> </li>
  </ol>
  <h2>Instructions for Front-End Developers</h2>
  <p>The main task in enaging a front-end developer to create a SPA for AEM is to agree on the components and their JSON models.<br /> </p> 
  <p>The following is an outline of the steps a front-end developer needs to follow when developing a SPA for AEM.</p> 
  <ol>
   <li> <p>Front-end developers and back-end AEM developers need to agree on which components are necessary and a model so there is a one-on-one match from SPA components to the back end components.</p> <p>AEM components are still necessary mostly to provide edit dialogs and to export the component model.<br /> </p> </li>
   <li> <p>Once components are agreed and the JSON model is in place, the front-end developer is free to develop the SPA and can simply access the JSON model via <span class="code">this.props.cqModel</span>.</p> </li>
   <li> <p>The front-end developer implements the <span class="code">render()</span> method as he/she sees fit and can use the fields of the <span class="code">cqModel</span> property. This outputs the DOM and the HTML fragments that will be inserted into the page. This is the standard way of building an app in React.</p> </li>
   <li> <p>The mapping stores component classes and is used internally by the provided <span class="code">Container</span> component to retrieve and dynamically instantiate components based on the given resource type. <br /> </p> <p>This serves as the "glue" between front end and back end so editor knows to which components the react components correspond.</p> <p>The <span class="code">Page</span> and <span class="code">ResponsiveGrid</span> are good examples of classes extending the base <span class="code">Container</span>.<br /> </p> </li>
   <li> <p>This parameter is necessary to tell the editor how the component should be named as long at is not yet rendered or has no content to render.</p> </li>
   <li> <p>Pages and paragraph systems should extend this class so that delegation to inner components works as expected.</p> </li>
   <li> <p>When the <span class="code">ModelRouter</span> is enabled, calling the <span class="code">pushState</span> and <span class="code">replaceState</span> functions will trigger a request to the <span class="code">PageModelManager</span> to fetch a missing fragment of the model.</p> <p>The current version of the <span class="code">ModelRouter</span> only support the use of URLs that points to the actual resource path of Sling Model entry points. It doesn't support the use of vanity URLs or aliases. </p> <p>The <span class="code">ModelRouter</span> can be disabled or configured to ignore a list of regular expressions.</p> </li>
  </ol>
  <h2>AEM-Agnostic</h2>
  <p>These code blocks illustrate how your React and Angular components need nothing that is Adobe or AEM specific.</p> 
  <ul> 
   <li>Everything that is inside the JavaScript component is AEM-agnostic.</li> 
   <li>What is however specific to AEM is that the JS component must be mapped to an AEM component with the MapTo helper.</li> 
  </ul> 
  <img imageRotate="0" src="assets/screen_shot_2018-12-11at144019.png" />
  <p>The <span class="code">MapTo</span> helper is the “glue” that allows the back-end and the front-end components to be matched together:</p> 
  <ul> 
   <li>It tells the JS container (or JS paragraph system) what JS component is responsible for rendering each of the components that are present in the JSON.</li> 
   <li>It adds an HTML data attribute to the HTML that the JS component renders, so that the SPA Editor knows what dialog to display to the author when editing the component.</li> 
  </ul> 
  <p>For more information about using <span class="code">MapTo</span> and building SPAs for AEM in general, see the Getting Started guide for your chosen framework.</p> 
  <ul> 
   <li><a href="../../../sites/developing/using/spa-getting-started-react.md">Getting Started with SPAs in AEM - React</a></li> 
   <li><a href="../../../sites/developing/using/spa-getting-started-angular.md">Getting Started with SPAs in AEM - Angular</a></li> 
  </ul> 
  <h2>AEM Architecture and SPAs</h2>
  <p>The general architecture of AEM including development, authoring, and publishing environments does not change when using SPAs. However it is helpful to understand how SPA development fits into this architecture.</p> 
  <img imageRotate="0" src="assets/screen_shot_2018-12-11at145348.png" />
  <ul>
   <li> <p>This is where the source for the SPA application source and component source are checked-out.</p> 
    <ul> 
     <li>The NPM clientlib generator creates a client library from the SPA project.</li> 
     <li>That library will be taken by Maven and deployed by the Maven Build plugin along with the component to the AEM Author.</li> 
    </ul> 
    <draft-comment lastModifiedBy="fauchere" lastModifiedDate="2018-06-14T08:00:39.721-0400" type="annotation">
     The NPM clientlib generator is framework agnostic and pack a given build folder into a clientlib directory at a given location in a JCR content structure
    </draft-comment></li>
   <li> <p>Content is created on the AEM author, including authoring SPAs.</p> <p>When a SPA is edited using the SPA Editor on the authoring environment:</p> 
    <ol> 
     <li>The SPA requests the outer HTML.</li> 
     <li>The CSS is loaded.</li> 
     <li>The Javascript of the SPA application is loaded.</li> 
     <li>When the SPA application is executed, the JSON is requested, allowing the app to build the DOM of the page including the <span class="code">cq-data</span> attributes.</li> 
     <li>This <span class="code">cq-data</span> attributes allows the editor to load additional page information so that it knows what edit configurations are available for the components.</li> 
    </ol> 
    <draft-comment lastModifiedBy="fauchere" lastModifiedDate="2018-06-14T08:11:51.515-0400" type="annotation">
     I don't know if this document should be framework agnostic or reference a particular framework. If we want it to be specific then we may have to consider multiplying the variations - one for each framework we are supporting
    </draft-comment></li>
   <li> <p>This is where the authored content and compiled libraries including SPA application artifacts, clientlibs, and components are published for public consumption.</p> 
    <draft-comment lastModifiedBy="fauchere" lastModifiedDate="2018-06-14T08:18:29.753-0400" type="annotation">
     As long as the SPA project is built outside of AEM it means that the developer must built with different flavours - one for dev while developing the App and one for the Author and Publish instances
    </draft-comment></li>
   <li> <p>The dispatcher serves as the caching layer of AEM for visitors to the site.</p> 
    <ul> 
     <li>Requests are processed similar to how they are on the AEM Author, however there is no request of the page information since this is only needed by the editor.</li> 
     <li>Javascript, CSS, JSON, and HTML is cached, optimizing the page for fast delivery.</li> 
    </ul> </li>
  </ul>
  <note>
   <p>Inside AEM there is no need to execute Javascript build mechanisms or to execute the Javascript itself. AEM only hosts the compiled artifacts from the SPA application.</p> 
  </note>
  <h2>Next Steps</h2>
  <p>For an overview of how a simple SPA in AEM is structured and how it works, see the getting started guide for both <a href="../../../sites/developing/using/spa-getting-started-react.md">React</a> and <a href="../../../sites/developing/using/spa-getting-started-angular.md">Angular</a>.<br /> </p> 
  <p>For a step-by-step guide to creating your own SPA, see the <a href="/content/help/en/experience-manager/kt/sites/using/getting-started-spa-wknd-tutorial-develop">Getting Started with the AEM SPA Editor - WKND Events Tutorial</a>.</p> 
  <p>For further details about the dynamic model to component mapping and how it works within SPAs in AEM, see the article <a href="../../../sites/developing/using/spa-dynamic-model-to-component-mapping.md">Dynamic Model to Component Mapping for SPAs</a>.</p> 
  <p>If you wish to implement SPAs in AEM for a framework other than React or Angular or simply wish to take a deep dive into how the SPA SDK for AEM works, refer to the <a href="../../../sites/developing/using/spa-blueprint.md">SPA Blueprint</a> article.</p> 
 </body>
</html>